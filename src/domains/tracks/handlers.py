import asyncio
import logging

import aiofiles
from aiogram import Bot, F, types
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import CallbackQuery
from dishka import FromDishka
from dishka.integrations.aiogram import inject

from src.domains.tracks import track_router
from src.domains.tracks.keyboards import track_list_kb
from src.service.downloader.service import DownloaderService


class FindTrackStates(StatesGroup):
    WAITING_FOR_PHRASE = State()
    WAITING_FOR_LINK = State()


@track_router.callback_query(
    F.data == "find_track",
)
@inject
async def search_tracks(
    callback: types.CallbackQuery,
    state: FSMContext,
):
    await callback.answer()
    await callback.message.edit_text("üìù –í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø–µ—Å–Ω–∏, –∏—Å–ø–æ–ª–Ω–∏—Ç–µ–ª—è.")
    await state.set_state(FindTrackStates.WAITING_FOR_PHRASE)


@track_router.message(FindTrackStates.WAITING_FOR_PHRASE)
@inject
async def handle_preview_search_track(
    message: types.Message,
    state: FSMContext,
    bot: Bot,
    downloader: FromDishka[DownloaderService],
):
    # –°–∏–º–≤–æ–ª—ã —Å–ø–∏–Ω–Ω–µ—Ä–∞
    spinner = [
        "üîé–ü–æ–∏—Å–∫ ‚†ã",
        "üîé–ü–æ–∏—Å–∫ ‚†ô",
        "üîé–ü–æ–∏—Å–∫ ‚†π",
        "üîé–ü–æ–∏—Å–∫ ‚†∏",
        "üîé–ü–æ–∏—Å–∫ ‚†º",
        "üîé–ü–æ–∏—Å–∫ ‚†¥",
        "üîé–ü–æ–∏—Å–∫ ‚†¶",
        "üîé–ü–æ–∏—Å–∫ ‚†ß",
        "üîé–ü–æ–∏—Å–∫ ‚†á",
        "üîé–ü–æ–∏—Å–∫ ‚†è",
    ]
    index = 0

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    loading_msg = await message.answer(spinner[index])

    # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–∏—Å–∫–æ–≤—É—é –∑–∞–¥–∞—á—É –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –∫–æ—Ä—É—Ç–∏–Ω–µ
    task = asyncio.create_task(downloader.find_tracks_on_phrase(message.text))

    # –ê–Ω–∏–º–∞—Ü–∏—è —Å–ø–∏–Ω–Ω–µ—Ä–∞ –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏
    while not task.done():
        index = (index + 1) % len(spinner)
        await loading_msg.edit_text(spinner[index])
        await asyncio.sleep(0.2)

    # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    preview_phrase = task.result()

    # –û—á–∏—â–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    await loading_msg.delete()

    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥—Ö–æ–¥—è—â—É—é –ø–µ—Å–Ω—é:",
        reply_markup=await track_list_kb(preview_phrase),
    )

    await state.clear()


@track_router.callback_query(F.data.startswith("track_url:"))
@inject
async def callback_query(
    callback: CallbackQuery,
    bot: Bot,
    downloader: FromDishka[DownloaderService],
    logger: FromDishka[logging.Logger],
):
    await callback.answer("–°—Å—ã–ª–∫–∞ –ø–æ–ª—É—á–µ–Ω—ã, —Å–∫–∞—á–∞—é —Ñ–∞–π–ª.")
    link = callback.data.split("track_url:")[-1]

    if not link:
        await callback.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É.")
        return

    # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–∏—Å–∫–æ–≤—É—é –∑–∞–¥–∞—á—É –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –∫–æ—Ä—É—Ç–∏–Ω–µ
    track_path_task = asyncio.create_task(downloader.download_track(link))

    spinner = [
        "üõ¨ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ‚†ã",
        "üõ¨ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ‚†ô",
        "üõ¨ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ‚†π",
        "üõ¨ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ‚†∏",
        "üõ¨ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ‚†º",
        "üõ¨ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ‚†¥",
        "üõ¨ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ‚†¶",
        "üõ¨ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ‚†ß",
        "üõ¨ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ‚†á",
        "üõ¨ –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–µ–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ‚†è",
    ]
    index = 0

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    loading_msg = await callback.message.answer(spinner[index])

    # –ê–Ω–∏–º–∞—Ü–∏—è —Å–ø–∏–Ω–Ω–µ—Ä–∞ –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–∞–¥–∞—á–∏
    while not track_path_task.done():
        index = (index + 1) % len(spinner)
        await loading_msg.edit_text(spinner[index])
        await asyncio.sleep(0.2)

    await loading_msg.delete()
    track_path = track_path_task.result()
    logger.debug(f"Downloading track '{track_path}'")
    try:
        async with aiofiles.open(f"{track_path}.mp3", "rb") as f:
            file_content = await f.read()
            await bot.send_audio(
                chat_id=callback.message.chat.id,
                audio=types.input_file.BufferedInputFile(
                    file_content, filename="track.mp3"
                ),
            )
    except Exception as e:
        logger.error(e)
        raise
